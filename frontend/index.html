<!--
  Fraud Detection Showcase — Updated Single HTML (v3)
  - Uses real PNGs for original/reconstructed comparison in Concept section.
  - Stylizes "Explore idea" button (hero page).
  - Preserves all design/animations; disables fake waveform drawing.
-->
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Transactional Fraud Detection — Showcase</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
  <style>
    :root{
      --bg-offwhite:#fbfbfb;
      --card-white:#ffffff;
      --muted:#6b7280;
      --accent-blue:#1f77b4;
      --accent-orange:#ff7f0e;
      --radius:14px;
      --shadow: 0 12px 30px rgba(8,15,30,0.06);
      --hover-shadow: 0 20px 40px rgba(8,15,30,0.08);
      --ease: cubic-bezier(.2,.9,.25,1);
      --max-width:1180px;
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:var(--bg-offwhite);font-family:Inter,system-ui,-apple-system,'Segoe UI',Roboto,Arial;color:#0f172a}
    a{color:var(--accent-blue);text-decoration:none}
    /* Header */
    header.topbar{
      max-width:var(--max-width);
      margin:18px auto;
      padding:14px 18px;
      border-radius:12px;
      background:linear-gradient(180deg,rgba(255,255,255,0.92),rgba(255,255,255,0.88));
      box-shadow:var(--shadow);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
    }
    .brand{display:flex;gap:12px;align-items:center}
    .logo{width:56px;height:56px;border-radius:12px;background:linear-gradient(135deg,var(--accent-blue),var(--accent-orange));display:flex;align-items:center;justify-content:center;color:white;font-weight:700;font-size:1.05rem}
    .brand h1{font-size:1.02rem;margin:0}
    .brand p{margin:0;color:var(--muted);font-size:0.88rem}
    .nav{display:flex;gap:10px}
    .nav button{
      background:var(--card-white);
      border:1px solid rgba(12,20,40,0.05);
      padding:10px 12px;
      border-radius:10px;
      cursor:pointer;
      font-weight:600;
      transition:transform .18s var(--ease),box-shadow .18s var(--ease);
      box-shadow: 0 6px 16px rgba(12,20,40,0.03);
    }
    .nav button:hover{transform:translateY(-4px);box-shadow:var(--hover-shadow)}
    /* Stylized Explore Idea Button */
    .navbtn {
      background: linear-gradient(90deg,var(--accent-blue) 65%,var(--accent-orange) 100%);
      color: #fff;
      font-weight: 700;
      border: none;
      border-radius: 999px;
      box-shadow: 0 6px 18px rgba(31,119,180,0.11);
      padding: 12px 28px;
      font-size: 1rem;
      letter-spacing: 0.02em;
      cursor: pointer;
      transition: box-shadow .18s var(--ease),transform .18s var(--ease),background .22s var(--ease);
      position: relative;
      outline: none;
    }
    .navbtn:after {
      content: "";
      position: absolute;
      left: 12px; right: 12px; bottom: 8px; height: 8px;
      border-radius: 999px;
      background: linear-gradient(90deg,rgba(31,119,180,0.15),rgba(255,127,14,0.12));
      filter: blur(3px);
      opacity: 0.45;
      pointer-events: none;
      z-index: 0;
      transition: opacity .2s var(--ease);
    }
    .navbtn:hover {
      box-shadow:var(--hover-shadow);
      transform: translateY(-2px) scale(1.03);
      background: linear-gradient(90deg,var(--accent-blue) 55%,var(--accent-orange) 100%);
    }
    .navbtn:active {
      transform: scale(0.98);
      background: linear-gradient(90deg,var(--accent-blue) 75%,var(--accent-orange) 100%);
    }
    /* Main container & pages */
    main{max-width:var(--max-width);margin:22px auto;padding:10px;scroll-snap-type:y mandatory;overflow-y:auto;height:calc(100vh - 120px)}
    section.page{min-height:calc(100vh - 120px);display:flex;align-items:center;scroll-snap-align:start;padding:48px 20px;position:relative}
    .card{background:var(--card-white);border-radius:var(--radius);padding:24px;box-shadow:var(--shadow);border:1px solid rgba(10,20,30,0.03)}
    /* decorative art */
    .art{position:absolute;pointer-events:none;filter:blur(8px);opacity:0.12}
    .art.blue{right:-40px;top:40px;width:420px;height:40px;background:linear-gradient(90deg,var(--accent-blue),transparent);transform:rotate(12deg)}
    .art.orange{left:-40px;bottom:40px;width:300px;height:28px;background:linear-gradient(90deg,var(--accent-orange),transparent);transform:rotate(-6deg)}
    /* hero */
    .hero{display:grid;grid-template-columns:1fr 420px;gap:30px;align-items:center;width:100%}
    .hero h2{font-size:2.2rem;margin:0}
    .hero p{color:var(--muted);line-height:1.5}
    .row{display:flex;gap:12px;align-items:center}
    .spacer{flex:1}
    /* image */
    .image-card{width:100%;height:300px;border-radius:12px;overflow:hidden;border:1px solid rgba(0,0,0,0.04);display:flex;align-items:center;justify-content:center;background:linear-gradient(180deg,#fff,#fafafa)}
    .image-card img{max-width:100%;max-height:100%;display:block;transition:transform .45s var(--ease);box-shadow: 0 10px 30px rgba(12,20,40,0.06)}
    .image-card:hover img{transform:translateY(-6px) scale(1.01)}
    /* text */
    .section-title{font-size:1.6rem;margin-bottom:8px}
    .muted{color:var(--muted)}
    /* recon */
    .recon-row{display:flex;gap:18px;flex-wrap:wrap;align-items:center}
    .recon-card{width:320px;border-radius:10px;padding:12px;background:linear-gradient(180deg,#fff,#fcfcfc);border:1px solid rgba(0,0,0,0.04);display:flex;flex-direction:column;gap:10px;box-shadow:0 10px 26px rgba(8,15,30,0.02)}
    .recon-img{width:100%;height:120px;border-radius:8px;overflow:hidden;display:flex;align-items:center;justify-content:center;background:linear-gradient(180deg,#fff,#f6f6f8)}
    .recon-img img{max-width:100%;max-height:100%;border-radius:8px;box-shadow:0 4px 16px rgba(31,119,180,0.08)}
    .recon-label{font-weight:700;color:var(--accent-blue);font-size:0.95rem}
    .recon-label.reconstructed{color:var(--accent-orange);}
    /* steps */
    .steps{display:flex;flex-direction:column;gap:14px;width:100%;max-width:720px}
    .step{display:flex;gap:12px;align-items:flex-start}
    .num{width:46px;height:46px;border-radius:10px;background:var(--card-white);border:1px solid rgba(0,0,0,0.04);display:flex;align-items:center;justify-content:center;font-weight:700;color:var(--accent-blue);box-shadow: 0 8px 18px rgba(12,20,40,0.04)}
    .desc{color:var(--muted)}
    /* charts area */
    .charts{display:flex;gap:18px;flex-wrap:wrap;align-items:flex-start}
    .chart-box{width:900px;padding:12px;border-radius:10px;background:linear-gradient(180deg,#fff,#fafafa);border:1px solid rgba(0,0,0,0.04);box-shadow:0 14px 30px rgba(8,15,30,0.04);position:relative}
    canvas{display:block;width:100%;height:220px}
    /* metrics table */
    .metrics-table{border-collapse:collapse;width:100%;max-width:680px}
    .metrics-table th,.metrics-table td{padding:8px 12px;border-bottom:1px solid #f1f5f9;text-align:left}
    .metrics-table th{background:transparent;color:var(--muted);font-weight:600}
    /* pager */
    .pager{position:fixed;right:18px;top:45%;display:flex;flex-direction:column;gap:10px}
    .pager button{width:10px;height:40px;border-radius:999px;border:none;background:linear-gradient(180deg,#eee,#ddd);opacity:0.7}
    .pager button.active{background:linear-gradient(180deg,var(--accent-blue),var(--accent-orange));opacity:1}
    /* toggles */
    .legend{display:flex;gap:8px;align-items:center}
    .legend .pill{background:var(--card-white);border:1px solid rgba(12,20,40,0.05);padding:6px 10px;border-radius:999px;cursor:pointer;box-shadow:0 6px 16px rgba(12,20,40,0.03);font-weight:600}
    .legend .pill.active{box-shadow:var(--hover-shadow)}
    /* small animation helpers */
    .fade{opacity:0;transform:translateY(12px);transition:opacity .6s var(--ease),transform .6s var(--ease)}
    .inview{opacity:1;transform:none}
    @media (max-width:980px){.hero{grid-template-columns:1fr}.image-card{height:200px}.charts{flex-direction:column}.chart-box{width:100%}}
  </style>
</head>
<body>
  <div class="art blue" aria-hidden="true"></div>
  <div class="art orange" aria-hidden="true"></div>

  <header class="topbar" role="banner">
    <div class="brand">
      <div class="logo">FD</div>
      <div>
        <h1 style="margin:0;font-size:1rem">Transactional Fraud Detection</h1>
        <p style="margin:0">By <strong>Manas Ranjan Jena</strong></p>
      </div>
    </div>

    <nav class="nav" role="navigation" aria-label="Primary">
      <button data-target="hero">Home</button>
      <button data-target="concept">Idea</button>
      <button data-target="process">Process</button>
      <button data-target="results">Results</button>
      <button data-target="credits">Credits</button>
    </nav>
  </header>

  <main id="main">
    <!-- Page 1: Hero -->
    <section id="hero" class="page">
      <div style="width:100%;display:grid;grid-template-columns:1fr 420px;gap:26px;align-items:center">
        <div>
          <h2 style="margin:0 0 8px" class="section-title">Transactional Fraud Detection</h2>
          <p class="muted">A hybrid anomaly-detection pipeline using Autoencoders and traditional ML classifiers to identify suspicious transactions.</p>
          <div style="height:18px"></div>
          <div class="row">
            <button class="navbtn" onclick="goto('concept')">Explore idea</button>
            <div class="spacer"></div>
          </div>
        </div>

        <div>
          <div class="image-card card" id="imageCard" aria-hidden="true">
            <!-- Put AutoEncoder_Performance_On_Test_Data.png next to this HTML -->
            <img id="reconPNG" src="AutoEncoder_Performance_On_Test_Data.png" alt="Autoencoder performance on test data">
          </div>
        </div>
      </div>
    </section>

    <!-- Page 2: Concept -->
    <section id="concept" class="page">
      <div class="card" style="max-width:980px">
        <div style="display:flex;justify-content:space-between;align-items:flex-start;gap:12px;flex-wrap:wrap">
          <div style="flex:1;min-width:280px">
            <h3 class="section-title">The Idea & Approach</h3>
            <p id="typeConcept" class="muted">(loading summary...)</p>
          </div>

          <div style="width:380px">
            <div class="recon-row">
              <div class="recon-card fade">
                <div class="recon-label">Original (vector)</div>
                <div class="recon-img">
                  <!-- Use real PNG for original -->
                  <img src="Original.png" alt="Original data vector">
                </div>
              </div>
              <div class="recon-card fade">
                <div class="recon-label reconstructed">Reconstructed</div>
                <div class="recon-img">
                  <!-- Use real PNG for reconstructed -->
                  <img src="Reconstructed.png" alt="Reconstructed data vector">
                </div>
              </div>
            </div>
          </div>
        </div>

        <div style="height:12px"></div>
        <div class="muted">The landing image shows AutoEncoder performance on held-out test data (visualized as a PNG). The autoencoder learns normal transaction patterns; large reconstruction deviations signal anomalies. The two images above compare the original data and its autoencoder reconstruction.</div>
      </div>
    </section>

    <!-- Page 3: Process -->
    <section id="process" class="page">
      <div style="width:100%;max-width:980px">
        <div class="card">
          <h3 class="section-title">How It Works — Process & Workflow</h3>
          <div style="height:8px"></div>
          <div class="steps">
            <div class="step fade">
              <div class="num">1</div>
              <div>
                <div style="font-weight:700">Data preprocessing & feature engineering</div>
                <div class="desc muted">Handle missing values, perform encodings, trim obvious outliers and scale features using MinMax. Engineer time-based and behavioural features (time deltas, frequency windows). These steps reduce distributional noise and improve model stability.</div>
              </div>
            </div>

            <div class="step fade" style="transition-delay:.04s">
              <div class="num">2</div>
              <div>
                <div style="font-weight:700">Autoencoder training</div>
                <div class="desc muted">A bottleneck architecture compresses inputs into latent space and reconstructs them. Trained primarily on legitimate transactions with early stopping to avoid memorization. The autoencoder learns the normal data manifold — deviations imply anomalies.</div>
              </div>
            </div>

            <div class="step fade" style="transition-delay:.08s">
              <div class="num">3</div>
              <div>
                <div style="font-weight:700">Reconstruction error as anomaly score</div>
                <div class="desc muted">Compute per-sample MSE between original & reconstructed features. Use percentile/statistical thresholds to flag anomalies, making thresholding robust across feature sets and operating points.</div>
              </div>
            </div>

            <div class="step fade" style="transition-delay:.12s">
              <div class="num">4</div>
              <div>
                <div style="font-weight:700">Hybrid classification & decisioning</div>
                <div class="desc muted">A Stacking Classifier where the base models are XGBClassifier, Logistic Regression, and RandomForestClassifier, and the meta-model is GaussianNB. This ensemble leverages the strengths of gradient boosting, linear modeling, and bagging-based trees, with the probabilistic meta-model improving generalization and handling uncertainty in predictions.</div>
              </div>
            </div>
          </div>

          <div style="height:18px"></div>
          <div class="chart-box card" id="reconVis">
            <canvas id="reconVisCanvas" width="960" height="220" aria-label="Reconstruction comparison visualization"></canvas>
          </div>
        </div>
      </div>
    </section>

    <!-- Page 4: Results -->
    <section id="results" class="page">
      <div style="width:100%;max-width:1180px">
        <div class="card">
          <h3 class="section-title">Results & Insights</h3>

          <div style="display:flex;gap:18px;flex-wrap:wrap;margin-top:8px">
            <div style="flex:1;min-width:320px">
              <div style="font-weight:700;margin-bottom:8px">Classification Reports</div>
              <table class="metrics-table" aria-label="Classification reports">
                <thead>
                  <tr><th>Dataset</th><th>Class</th><th>Precision</th><th>Recall</th><th>F1-score</th><th>Support</th></tr>
                </thead>
                <tbody>
                  <tr><td rowspan="2">Train</td><td>0.0</td><td>1.00</td><td>1.00</td><td>1.00</td><td>45491</td></tr>
                  <tr><td>1.0</td><td>1.00</td><td>1.00</td><td>1.00</td><td>78</td></tr>

                  <tr><td rowspan="2">Test</td><td>0.0</td><td>1.00</td><td>1.00</td><td>1.00</td><td>11373</td></tr>
                  <tr><td>1.0</td><td>0.86</td><td>0.95</td><td>0.90</td><td>20</td></tr>
                </tbody>
              </table>

              <div style="height:12px"></div>
              <div class="muted">Train shows perfect results — check for potential overfitting via validation curves. Test metrics: strong recall (0.95) for fraud but slightly lower precision (0.86), indicating some false positives; threshold and decision rules can be tuned based on operational cost.</div>
            </div>

            <div style="width:440px;min-width:320px">
              <div style="display:flex;align-items:center;justify-content:space-between">
                <div style="font-weight:700">Metric comparisons</div>
                <div class="legend">
                  <div class="pill active" id="toggleTrain">Train</div>
                  <div class="pill active" id="toggleTest">Test</div>
                </div>
              </div>

              <div style="height:12px"></div>
              <div class="charts">
                <div class="chart-box" id="groupedChartBox"><canvas id="groupedChart" aria-label="Grouped metrics chart"></canvas></div>
                <div style="height:10px"></div>
                <div class="chart-box" id="supportChartBox"><canvas id="supportChart" aria-label="Support counts chart"></canvas></div>
              </div>
            </div>

          </div>
        </div>
      </div>
    </section>

    <!-- Page 5: Credits -->
    <section id="credits" class="page">
      <div class="card" style="max-width:900px;text-align:left">
        <h3 class="section-title">Closing & Next Steps</h3>
        <p class="muted">Thank you for viewing this showcase. Next steps: model monitoring, drift detection, retraining cadence, and adding explainability (SHAP) so analysts can interpret flagged transactions.</p>
        <div style="height:12px"></div>
        <div style="display:flex;gap:12px;align-items:center;flex-wrap:wrap">
          <a class="navbtn" href="https://github.com/ManasRanjanJena253" target="_blank">GitHub</a>
          <a class="navbtn" href="https://www.linkedin.com/in/manasranjanjena253/" target="_blank">LinkedIn</a>
        </div>
      </div>
    </section>
  </main>

  <div class="pager" aria-hidden="true">
    <button id="p0" class="active" onclick="goto('hero')"></button>
    <button id="p1" onclick="goto('concept')"></button>
    <button id="p2" onclick="goto('process')"></button>
    <button id="p3" onclick="goto('results')"></button>
    <button id="p4" onclick="goto('credits')"></button>
  </div>

<script>
const metrics = {
  train: {
    class0: {precision:1.00, recall:1.00, f1:1.00, support:45491},
    class1: {precision:1.00, recall:1.00, f1:1.00, support:78},
    accuracy:1.00
  },
  test: {
    class0: {precision:1.00, recall:1.00, f1:1.00, support:11373},
    class1: {precision:0.86, recall:0.95, f1:0.90, support:20},
    accuracy:1.00
  }
};
/* =========== Utility helpers =========== */
function easeOutCubic(t){ return 1 - Math.pow(1 - t, 3); }
function dprScale(canvas){
  const dpr = window.devicePixelRatio || 1;
  const rect = canvas.getBoundingClientRect();
  canvas.width = Math.round(rect.width * dpr);
  canvas.height = Math.round(rect.height * dpr);
  const ctx = canvas.getContext('2d');
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  return ctx;
}
function createTooltip(){
  let tip = document.getElementById('chartTooltip');
  if(tip) return tip;
  tip = document.createElement('div');
  tip.id = 'chartTooltip';
  tip.style.position='fixed';
  tip.style.padding='8px 10px';
  tip.style.background='rgba(18,20,25,0.92)';
  tip.style.color='#fff';
  tip.style.borderRadius='6px';
  tip.style.fontSize='13px';
  tip.style.pointerEvents='none';
  tip.style.zIndex=9999;
  tip.style.display='none';
  document.body.appendChild(tip);
  return tip;
}
const tooltip = createTooltip();

/* =========== Page navigation & pager =========== */
const pages=['hero','concept','process','results','credits'];
function goto(id){ document.getElementById(id).scrollIntoView({behavior:'smooth'}); }
document.querySelectorAll('header .nav button').forEach(b => b.addEventListener('click', () => goto(b.dataset.target)));
const pagerButtons = Array.from(document.querySelectorAll('.pager button'));
const sections = pages.map(id => document.getElementById(id));
const pageObserver = new IntersectionObserver(entries => {
  entries.forEach(e => {
    if(e.isIntersecting){
      const idx = sections.indexOf(e.target);
      pagerButtons.forEach(pb => pb.classList.remove('active'));
      if(pagerButtons[idx]) pagerButtons[idx].classList.add('active');
      // reveal inner elements
      e.target.querySelectorAll('.fade, .recon-card, .chart-box, .step').forEach(el => el.classList.add('inview'));
      // trigger results charts when visible
      if(e.target.id === 'results') initResultsCharts();
    }
  });
}, { threshold: 0.28 });
sections.forEach(s => pageObserver.observe(s));

/* =========== Typing summary =========== */
const conceptEl = document.getElementById('typeConcept');
const conceptText = `This project combines a reconstruction-based Autoencoder with a complementary machine learning classifier. Inference uses MinMax-scaled features; the autoencoder identifies anomalies via reconstruction error, and the classifier refines decisions into Not-Fraud / Risky / Fraud outputs. The hybrid design provides strong detection while allowing operational controls through thresholding and confidence-based labels.`;
function typeText(el, text, speed=16){
  let i=0; const cursor="▌";
  function step(){
    if(i <= text.length){
      el.textContent = text.slice(0,i) + cursor;
      i++;
      setTimeout(step, speed + Math.random()*12);
    } else {
      el.textContent = text;
    }
  }
  step();
}
setTimeout(()=>typeText(conceptEl, conceptText, 14), 580);

/* =========== Disabling fake waveform drawing (Concept) =========== */
/* No more drawWaveforms -- real PNGs are now displayed */

/* =========== Reconstruction visualization in 'process' section =========== */
function drawReconVis(){
  const canvas = document.getElementById('reconVisCanvas');
  const ctx = dprScale(canvas);
  const w = canvas.clientWidth, h = canvas.clientHeight;
  const base = [];
  for(let x=0;x<=w;x+=10) base.push({x, y: h/2 + 10*Math.sin(x/26) + 6*Math.cos(x/16)});
  let t=0;
  function step(){
    ctx.clearRect(0,0,w,h);
    // grid
    ctx.strokeStyle='#f3f4f6'; ctx.lineWidth=1;
    for(let x=0;x<w;x+=40){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,h); ctx.stroke(); }
    // original
    ctx.beginPath(); ctx.strokeStyle='rgba(31,119,180,0.96)'; ctx.lineWidth=2.6;
    const len = Math.floor(base.length * Math.min(1, t));
    for(let i=0;i<len;i++){ const p=base[i]; if(i===0) ctx.moveTo(p.x, p.y); else ctx.lineTo(p.x, p.y); }
    ctx.save(); ctx.shadowColor='rgba(31,119,180,0.16)'; ctx.shadowBlur=8; ctx.stroke(); ctx.restore();
    // recon
    ctx.beginPath(); ctx.strokeStyle='rgba(255,127,14,0.92)'; ctx.lineWidth=2;
    for(let i=0;i<len;i++){ const p=base[i]; const y = p.y + 3*Math.sin(i/6); if(i===0) ctx.moveTo(p.x, y); else ctx.lineTo(p.x, y); }
    ctx.save(); ctx.shadowColor='rgba(255,127,14,0.12)'; ctx.shadowBlur=6; ctx.stroke(); ctx.restore();
    t += 0.02;
    if(t < 1.5) requestAnimationFrame(step);
  }
}
new IntersectionObserver(entries => {
  entries.forEach(e => {
    if(e.isIntersecting){
      drawReconVis();
      e.target.querySelectorAll('.step').forEach(el => el.classList.add('inview'));
      this.disconnect && this.disconnect();
    }
  });
}, { threshold: 0.28 }).observe(document.getElementById('process'));

/* =========== Results charts (grouped metrics + support) =========== */
let groupedChartInitialized = false;
let showTrain = true, showTest = true;

document.getElementById('toggleTrain').addEventListener('click', function(){
  showTrain = !showTrain;
  this.classList.toggle('active');
  redrawGroupedChart(true);
});
document.getElementById('toggleTest').addEventListener('click', function(){
  showTest = !showTest;
  this.classList.toggle('active');
  redrawGroupedChart(true);
});

function initResultsCharts(){
  if(groupedChartInitialized) return;
  groupedChartInitialized = true;
  redrawGroupedChart(false);
  drawSupportChart();
}

function redrawGroupedChart(animate=true){
  const canvas = document.getElementById('groupedChart');
  const ctx = dprScale(canvas);
  const w = canvas.clientWidth, h = canvas.clientHeight;
  // groups
  const groups = ['Precision','Recall','F1'];
  // matrix: each group -> [train0, train1, test0, test1]
  const getVal = (gindex, bi) => {
    const metricKey = groups[gindex].toLowerCase();
    const raw = [metrics.train.class0[metricKey], metrics.train.class1[metricKey], metrics.test.class0[metricKey], metrics.test.class1[metricKey]][bi];
    if(bi <= 1 && !showTrain) return 0;
    if(bi >= 2 && !showTest) return 0;
    return raw;
  };
  // colors
  const colors = ['rgba(31,119,180,0.98)','rgba(255,127,14,0.98)','rgba(31,119,180,0.55)','rgba(255,127,14,0.55)'];
  const labels = ['Train 0','Train 1','Test 0','Test 1'];
  // animation loop
  let t = 0;
  const barMeta = []; // will be recomputed each frame
  function drawFrame(){
    ctx.clearRect(0,0,w,h);
    // baseline axis
    ctx.strokeStyle = '#eef2f7'; ctx.lineWidth = 1; ctx.beginPath(); ctx.moveTo(40, h-40); ctx.lineTo(w-20, h-40); ctx.stroke();
    // groups
    const groupWidth = (w - 80) / groups.length;
    barMeta.length = 0;
    for(let gi=0; gi<groups.length; gi++){
      const gx = 40 + gi*groupWidth + 8;
      const bw = (groupWidth - 28) / 4; // 4 slots
      for(let bi=0; bi<4; bi++){
        const raw = getVal(gi, bi);
        const targetH = (h - 100) * raw; // scale to canvas
        const progress = easeOutCubic(Math.min(1, t));
        const drawH = targetH * (animate ? progress : 1);
        const bx = gx + bi*(bw + 6);
        const by = h - 40 - drawH;
        ctx.beginPath();
        ctx.fillStyle = colors[bi];
        ctx.shadowColor = 'rgba(12,20,40,0.10)';
        ctx.shadowBlur = 6;
        ctx.fillRect(bx, by, bw, drawH);
        ctx.shadowBlur = 0;
        // push meta for hover detection
        barMeta.push({x: bx, y: by, w: bw, h: drawH, label: labels[bi], value: raw, group: groups[gi]});
      }
      // group label
      ctx.fillStyle = '#0f172a'; ctx.font = '600 12px Inter';
      ctx.fillText(groups[gi], gx + (groupWidth / 2) - 14, h - 15);
    }
    // legend labels (draw small sample legends)
    ctx.fillStyle = '#0f172a'; ctx.font = '600 12px Inter';
    ctx.fillText('Train 0/1 (solid) — Test 0/1 (muted)', 44, 18);
    // draw interactive hover (tooltip)
    // tooltip is handled by mousemove listener using barMeta (below)
    t += 0.03;
    if(animate && t < 1.2) requestAnimationFrame(drawFrame);
    else {
      // final stabilization frame to ensure final values drawn
      if(animate) {
        t = 1;
        requestAnimationFrame(drawFrame);
      }
    }
    // store latest meta on canvas for event handlers
    canvas._barMeta = barMeta.slice();
  }
  drawFrame();
  // attach mouse events for tooltip and highlight
  canvas.onmousemove = function(ev){
    const rect = canvas.getBoundingClientRect();
    const mx = (ev.clientX - rect.left);
    const my = (ev.clientY - rect.top);
    const meta = canvas._barMeta || [];
    let found = null;
    for(const m of meta){
      if(mx >= m.x && mx <= m.x + m.w && my >= m.y && my <= m.y + m.h){
        found = m; break;
      }
    }
    if(found){
      tooltip.style.display = 'block';
      tooltip.textContent = `${found.group} — ${found.label}: ${(found.value*100).toFixed(2)}%`;
      tooltip.style.left = (ev.clientX + 10) + 'px';
      tooltip.style.top = (ev.clientY + 10) + 'px';
      // highlight by drawing a thin border over the bar
      const ctx2 = dprScale(canvas);
      // re-draw overlay outline quickly (non-destructive)
      ctx2.beginPath();
      ctx2.lineWidth = 2;
      ctx2.strokeStyle = 'rgba(0,0,0,0.12)';
      ctx2.strokeRect(found.x - 2, found.y - 2, found.w + 4, found.h + 4);
    } else {
      tooltip.style.display = 'none';
      // redraw to remove highlight (simple re-run without animation)
      redrawGroupedChart(false);
    }
  };
  canvas.onmouseleave = function(){ tooltip.style.display = 'none'; };
}

function drawSupportChart(){
  const canvas = document.getElementById('supportChart');
  const ctx = dprScale(canvas);
  const w = canvas.clientWidth, h = canvas.clientHeight;
  const supports = [metrics.train.class0.support, metrics.train.class1.support, metrics.test.class0.support, metrics.test.class1.support];
  const labels = ['Train 0','Train 1','Test 0','Test 1'];
  const colors = ['rgba(31,119,180,0.95)', 'rgba(255,127,14,0.95)', 'rgba(31,119,180,0.60)', 'rgba(255,127,14,0.60)'];
  const maxVal = Math.max(...supports);
  let progress = 0;
  const barMeta = [];
  function animate(){
    ctx.clearRect(0,0,w,h);
    // baseline
    ctx.strokeStyle = '#eef2f7'; ctx.lineWidth = 1; ctx.beginPath(); ctx.moveTo(20, h-30); ctx.lineTo(w-20, h-30); ctx.stroke();
    const gap = 18;
    const bw = (w - 60 - (labels.length-1)*gap) / labels.length;
    barMeta.length = 0;
    for(let i=0;i<labels.length;i++){
      const targetH = ((supports[i] / maxVal) * (h - 80));
      const drawH = targetH * easeOutCubic(Math.min(1, progress));
      const x = 20 + i*(bw + gap);
      const y = h - 30 - drawH;
      ctx.fillStyle = colors[i];
      ctx.shadowColor = 'rgba(12,20,40,0.10)'; ctx.shadowBlur = 8;
      ctx.fillRect(x, y, bw, drawH);
      ctx.shadowBlur = 0;
      // label and number
      ctx.fillStyle = '#0f172a'; ctx.font = '600 12px Inter';
      ctx.fillText(labels[i], x, h-8);
      ctx.fillStyle = '#0f172a'; ctx.font = '500 11px Inter';
      ctx.fillText(supports[i].toLocaleString(), x, y - 8);
      barMeta.push({x, y, w: bw, h: drawH, value: supports[i], label: labels[i]});
    }
    progress += 0.03;
    if(progress < 1) requestAnimationFrame(animate);
    // store meta for tooltip
    canvas._barMeta = barMeta.slice();
  }
  animate();
  // hover tooltip
  canvas.onmousemove = function(ev){
    const rect = canvas.getBoundingClientRect();
    const mx = ev.clientX - rect.left, my = ev.clientY - rect.top;
    const meta = canvas._barMeta || [];
    let found = null;
    for(const m of meta){
      if(mx >= m.x && mx <= m.x + m.w && my >= m.y && my <= m.y + m.h){ found = m; break; }
    }
    if(found){
      tooltip.style.display = 'block';
      tooltip.textContent = `${found.label}: ${found.value.toLocaleString()}`;
      tooltip.style.left = (ev.clientX + 10) + 'px';
      tooltip.style.top = (ev.clientY + 10) + 'px';
    } else {
      tooltip.style.display = 'none';
    }
  };
  canvas.onmouseleave = function(){ tooltip.style.display = 'none'; };
}

/* =========== Keyboard navigation (PageUp/PageDown or arrows) =========== */
let currentIndex = 0;
window.addEventListener('keydown', (e) => {
  if(e.key === 'ArrowDown' || e.key === 'PageDown'){ currentIndex = Math.min(currentIndex + 1, pages.length - 1); goto(pages[currentIndex]); }
  if(e.key === 'ArrowUp' || e.key === 'PageUp'){ currentIndex = Math.max(currentIndex - 0, 0); goto(pages[currentIndex]); }
});
window.addEventListener('scroll', () => {
  // update currentIndex by nearest section center
  const mid = window.scrollY + window.innerHeight/2;
  let nearest = 0, best = Infinity;
  sections.forEach((s, i) => {
    const r = s.getBoundingClientRect();
    const center = window.scrollY + r.top + r.height/2;
    const d = Math.abs(center - mid);
    if(d < best){ best = d; nearest = i; }
  });
  currentIndex = nearest;
});

/* =========== Parallax on hero image =========== */
const imgCard = document.getElementById('imageCard');
if(imgCard){
  imgCard.addEventListener('mousemove', (e) => {
    const rect = imgCard.getBoundingClientRect();
    const cx = rect.left + rect.width/2; const cy = rect.top + rect.height/2;
    const dx = (e.clientX - cx) / rect.width; const dy = (e.clientY - cy) / rect.height;
    const img = document.getElementById('reconPNG');
    if(img) img.style.transform = `translate(${dx * 6}px, ${dy * 6}px) scale(1.01)`;
  });
  imgCard.addEventListener('mouseleave', () => { const img = document.getElementById('reconPNG'); if(img) img.style.transform = ''; });
}

/* redraw grouped chart on resize with debounce */
let resizeTimer = null;
window.addEventListener('resize', () => {
  groupedChartInitialized = false;
  clearTimeout(resizeTimer);
  resizeTimer = setTimeout(() => {
    if(sections[3] && isElementInViewport(sections[3])) initResultsCharts();
  }, 220);
});
function isElementInViewport(el){ const r = el.getBoundingClientRect(); return r.top < window.innerHeight && r.bottom > 0; }

/* initial scroll nudge */
setTimeout(()=>{ document.getElementById('hero').scrollIntoView({behavior:'smooth'}); }, 180);
</script>
</body>
</html>